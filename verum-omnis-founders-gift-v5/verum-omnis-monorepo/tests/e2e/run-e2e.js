#!/usr/bin/env node
/**
 * End-to-end smoke test for Verum Omnis.
 *
 * Usage:
 *   node tests/e2e/run-e2e.js --base http://localhost:5001/api2
 *
 * The script hits the verify, anchor, and seal endpoints in sequence to confirm
 * the full flow (health ‚Üí anchor ‚Üí seal) works as expected.
 */

import { randomBytes } from 'crypto';
import { writeFile, rm } from 'fs/promises';

const args = process.argv.slice(2);
const baseFlagIndex = args.indexOf('--base');
const baseUrl =
  (baseFlagIndex !== -1 && args[baseFlagIndex + 1]) ||
  process.env.VERUM_API_BASE ||
  'http://localhost:5001/api2';

const hash = randomBytes(64).toString('hex');
const timeoutMs = 15_000;
const abort = new AbortController();

const timer = setTimeout(() => {
  abort.abort();
}, timeoutMs);

async function run() {
  console.log(`üîç Using API base: ${baseUrl}`);

  const health = await fetch(`${baseUrl}/v1/verify`, { signal: abort.signal });
  if (!health.ok) {
    throw new Error(`Health check failed with status ${health.status}`);
  }
  const healthJson = await health.json();
  if (!healthJson?.immutable_pack_verified) {
    throw new Error('Immutable pack verification flag missing or false');
  }
  console.log('‚úÖ Health check passed');

  const anchorRes = await fetch(`${baseUrl}/v1/anchor`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ hash }),
    signal: abort.signal,
  });
  if (!anchorRes.ok) {
    throw new Error(`Anchor failed with status ${anchorRes.status}`);
  }
  const anchorJson = await anchorRes.json();
  if (!anchorJson?.hash || anchorJson.hash !== hash) {
    throw new Error('Anchored hash mismatch');
  }
  console.log('ü™ù Anchor endpoint passed');

  const sealRes = await fetch(`${baseUrl}/v1/seal`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      hash,
      title: 'E2E Test Seal',
      notes: 'Automated verification seal generated by tests/e2e/run-e2e.js',
    }),
    signal: abort.signal,
  });
  if (!sealRes.ok) {
    throw new Error(`Seal endpoint failed with status ${sealRes.status}`);
  }
  const pdf = Buffer.from(await sealRes.arrayBuffer());
  if (pdf.length < 1024) {
    throw new Error('Sealed PDF appears too small');
  }
  const pdfPath = `.e2e-seal-${hash.slice(0, 8)}.pdf`;
  await writeFile(pdfPath, pdf);
  console.log(`üìÑ Sealed PDF saved to ${pdfPath}`);
  await rm(pdfPath, { force: true });
  console.log('üßπ Temporary PDF cleaned up');

  const contradictRes = await fetch(`${baseUrl}/v1/contradict`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ text: 'The contract was signed on 1 Jan 2024.', meta: {}, timeline: [] }),
    signal: abort.signal,
  });
  if (!contradictRes.ok) {
    throw new Error(`Contradiction endpoint failed with status ${contradictRes.status}`);
  }
  console.log('üß† Contradiction endpoint reachable');

  console.log('üéâ End-to-end flow verified successfully');
}

run()
  .catch((err) => {
    console.error('‚ùå End-to-end test failed');
    console.error(err);
    process.exitCode = 1;
  })
  .finally(() => {
    clearTimeout(timer);
  });
