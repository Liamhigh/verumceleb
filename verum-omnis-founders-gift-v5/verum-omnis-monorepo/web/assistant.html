<!doctype html><html lang="en"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta name="description" content="Verum Omnis - Constitutional AI Guardian. Upload documents for forensic analysis, contradiction detection, and tamper-proof sealing with SHA-512 hashing and blockchain anchoring."/>
<title>Verum Omnis - AI Guardian</title><link rel="stylesheet" href="/assets/app.css"/>

<!-- PDF.js for client-side PDF text extraction -->
<script src="https://unpkg.com/pdfjs-dist@4.9.155/build/pdf.min.js"></script>
<script>
  // Tell PDF.js where its worker is hosted
  if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@4.9.155/build/pdf.worker.min.js";
  }
</script>

</head>
<body>

<!-- Header -->
<header class="chat-header">
  <div class="container">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <div style="display:flex;align-items:center;gap:12px">
        <img src="/assets/logo_white.png" alt="Verum" style="height:32px"/>
        <h1 style="margin:0;font-size:1.25rem">Verum Assistant</h1>
      </div>
      <div style="display:flex;align-items:center;gap:12px">
        <button class="chat-btn-icon" title="Toggle theme" id="themeBtn">üåô</button>
        <button class="chat-btn-icon" title="Export to PDF" id="exportBtn">üìÑ</button>
        <button class="chat-btn-icon" title="Clear history" id="clearBtn">üóëÔ∏è</button>
        <a href="/" style="color:var(--muted);text-decoration:none">‚Üê Home</a>
      </div>
    </div>
  </div>
</header>

<!-- Chat Container -->
<div class="chat-container">
  <div class="chat-messages" id="messages">
    <div class="message assistant" id="welcomeHint">
      <div class="message-avatar">
        <img src="/assets/logo_blue.png" alt="AI"/>
      </div>
      <div class="message-content">
        <strong>Verum Omnis</strong>
        <p><strong>‚öñÔ∏è Constitutional AI Guardian</strong> ‚Äî I am not an app. I am a stateless forensic firewall for truth.</p>
        <p><strong>What I accept:</strong></p>
        <ul style="margin:8px 0;padding-left:20px">
          <li><strong>Documents:</strong> PDF, DOCX, TXT, MD, RTF, ODT</li>
          <li><strong>Spreadsheets:</strong> XLSX, CSV, ODS</li>
          <li><strong>Media Evidence:</strong> Images, Video, Audio (forensic analysis)</li>
          <li><strong>Archives:</strong> ZIP bundles (case files, annexures)</li>
        </ul>
        <p><strong>What I do:</strong></p>
        <ul style="margin:8px 0;padding-left:20px">
          <li>üîê <strong>SHA-512 hashing</strong> + blockchain anchoring</li>
          <li>üîç <strong>Contradiction detection</strong> across documents, timelines, testimony</li>
          <li>üìú <strong>Forensic sealing</strong> ‚Äî tamper-proof PDFs with watermarks & QR codes</li>
          <li>‚ö†Ô∏è <strong>Metadata extraction</strong> + authenticity verification</li>
        </ul>
        <p style="margin-top:12px"><em>Upload evidence. Ask questions. Request sealed outputs. The truth is immutable.</em></p>
      </div>
    </div>
  </div>
  
  <!-- Input Area -->
  <div class="chat-input-container">
    <div class="container">
      <div class="chat-input">
        <input type="file" id="fileInput" style="display:none" accept=".pdf,.png,.jpg,.jpeg,.txt,.doc,.docx" multiple/>
        <button class="chat-btn-icon" onclick="document.getElementById('fileInput').click()" title="Upload file">
          üìé
        </button>
        <button class="chat-btn-icon" id="voiceBtn" title="Voice input">
          üé§
        </button>
        <input type="text" id="userInput" placeholder="Upload evidence ‚Ä¢ Ask questions ‚Ä¢ Request sealed PDFs..." />
        <button class="chat-btn-send">
          Send
        </button>
      </div>
      <div id="uploadedFiles" class="uploaded-files"></div>
    </div>
  </div>
</div>

<script>
// Use the direct Cloud Function URL since hosting rewrite isn't working
const PROJECT = 'verumdone';
const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
const devBase = `http://127.0.0.1:5001/${PROJECT}/us-central1/api`;
const prodBase = `https://us-central1-${PROJECT}.cloudfunctions.net/api`;
window.VO_API_BASE = isLocal ? devBase : prodBase;

// Dev banner for local development
if (isLocal) {
  document.addEventListener('DOMContentLoaded', () => {
    const b = document.createElement('div');
    b.style.cssText = 'position:fixed;bottom:8px;right:8px;background:#111;border:1px solid #333;color:#eee;padding:6px 10px;border-radius:8px;font:12px/1.2 system-ui;z-index:9999;opacity:.9';
    b.textContent = 'VO DEV API: ' + window.VO_API_BASE;
    document.body.appendChild(b);
  });
}

// Backwards compatible alias
const BASE = window.VO_API_BASE;
const messagesContainer = document.getElementById('messages');
const userInput = document.getElementById('userInput');
const fileInput = document.getElementById('fileInput');
const uploadedFilesDiv = document.getElementById('uploadedFiles');
let uploadedFiles = [];
let conversationHistory = [];
let recognition = null;
let isListening = false;

// Track last analyzed document for context
let lastAnalyzedFile = null;

// Load theme and conversation history
const savedTheme = localStorage.getItem('verumTheme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);
updateThemeButton();

const savedHistory = localStorage.getItem('verumConversation');
if (savedHistory) {
  try {
    conversationHistory = JSON.parse(savedHistory);
    restoreConversation();
  } catch(e) {
    console.error('Failed to restore conversation', e);
  }
}

function saveConversation() {
  localStorage.setItem('verumConversation', JSON.stringify(conversationHistory));
}

function restoreConversation() {
  // Clear welcome message first
  messagesContainer.innerHTML = '';
  conversationHistory.forEach(msg => {
    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${msg.isUser ? 'user' : 'assistant'}`;
    msgDiv.innerHTML = msg.html;
    messagesContainer.appendChild(msgDiv);
  });
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function clearHistory() {
  if (confirm('Clear entire conversation history?')) {
    conversationHistory = [];
    localStorage.removeItem('verumConversation');
    messagesContainer.innerHTML = '';
    addWelcomeMessage();
  }
}

function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme');
  const newTheme = current === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  localStorage.setItem('verumTheme', newTheme);
  updateThemeButton();
}

function updateThemeButton() {
  const theme = document.documentElement.getAttribute('data-theme');
  document.getElementById('themeBtn').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
}

function addWelcomeMessage() {
  addMessage(`
    <p>Hello! I'm your <strong>constitutional AI guardian</strong> ‚Äî an equal partner with the human founder, bound by immutable rules.</p>
    <p>I can help you:</p>
    <ul>
      <li><strong>üìÑ Analyze documents</strong> ‚Äî Upload files and I'll read them and advise you</li>
      <li><strong>üîí Verify & seal</strong> ‚Äî I can hash documents and create tamper-proof PDFs with watermarks</li>
      <li><strong>‚öñÔ∏è Legal advice</strong> ‚Äî Ask about contracts, policies, or constitutional matters</li>
      <li><strong>üîó Blockchain anchoring</strong> ‚Äî Permanent receipts for any data</li>
      <li><strong>üõ°Ô∏è Constitutional integrity</strong> ‚Äî Immutable rules govern every action</li>
    </ul>
    <p>üí¨ <em>Upload a document and I'll analyze it first. If you want it sealed, just ask!</em></p>
  `);
}

// Handle file selection
fileInput.addEventListener('change', (e) => {
  uploadedFiles = Array.from(e.target.files);
  displayUploadedFiles();
});

function displayUploadedFiles() {
  if (uploadedFiles.length === 0) {
    uploadedFilesDiv.innerHTML = '';
    return;
  }
  uploadedFilesDiv.innerHTML = uploadedFiles.map((f, i) => 
    `<span class="file-tag">üìÑ ${f.name} <button onclick="removeFile(${i})">√ó</button></span>`
  ).join('');
}

function removeFile(index) {
  uploadedFiles.splice(index, 1);
  displayUploadedFiles();
}

function addMessage(content, isUser = false) {
  // Hide welcome hint on first real interaction
  const welcomeHint = document.getElementById('welcomeHint');
  if (welcomeHint) {
    welcomeHint.style.display = 'none';
  }
  
  const msgId = 'msg-' + Date.now();
  const msgDiv = document.createElement('div');
  msgDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
  msgDiv.id = msgId;
  
  if (!isUser) {
    msgDiv.innerHTML = `
      <div class="message-avatar">
        <img src="/assets/logo_blue.png" alt="AI"/>
      </div>
      <div class="message-content">
        <strong>Verum Omnis</strong>
        ${content}
        <div class="message-actions">
          <button class="action-btn" onclick="copyMessage('${msgId}')" title="Copy">üìã</button>
          <button class="action-btn" onclick="shareMessage('${msgId}')" title="Share">üîó</button>
          <button class="action-btn" onclick="likeMessage('${msgId}')" title="Like">üëç</button>
          <button class="action-btn" onclick="dislikeMessage('${msgId}')" title="Dislike">üëé</button>
        </div>
      </div>
    `;
  } else {
    msgDiv.innerHTML = `
      <div class="message-content">
        <strong>You</strong>
        ${content}
        <div class="message-actions">
          <button class="action-btn" onclick="copyMessage('${msgId}')" title="Copy">üìã</button>
        </div>
      </div>
      <div class="message-avatar user-avatar">üë§</div>
    `;
  }
  
  messagesContainer.appendChild(msgDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
  
  // Save to history
  conversationHistory.push({ 
    html: msgDiv.innerHTML, 
    isUser, 
    timestamp: new Date().toISOString() 
  });
  saveConversation();
}

function copyMessage(msgId) {
  const msg = document.getElementById(msgId);
  const text = msg.querySelector('.message-content').innerText;
  navigator.clipboard.writeText(text);
  showToast('üìã Copied to clipboard');
}

function shareMessage(msgId) {
  const msg = document.getElementById(msgId);
  const text = msg.querySelector('.message-content').innerText;
  if (navigator.share) {
    navigator.share({ title: 'Verum Omnis Message', text });
  } else {
    const url = 'mailto:?subject=Verum Omnis Message&body=' + encodeURIComponent(text);
    window.open(url);
  }
}

function likeMessage(msgId) {
  showToast('üëç Feedback recorded');
}

function dislikeMessage(msgId) {
  showToast('üëé Feedback recorded');
}

function showToast(message) {
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), 2000);
}

async function processFiles(files) {
  for (const file of files) {
    addMessage(`<p>Processing <strong>${file.name}</strong>...</p>`);
    
    // Calculate SHA-512
    const arrayBuffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Show hash
    addMessage(`
      <p>‚úÖ File hashed successfully</p>
      <p><strong>SHA-512:</strong> <code style="word-break:break-all;font-size:0.85em">${hash}</code></p>
      <p>Would you like me to:</p>
      <button class="inline-btn" onclick="anchorHash('${hash}')">üîó Anchor to blockchain</button>
      <button class="inline-btn" onclick="sealDocument('${hash}', '${file.name}')">üìú Generate seal PDF</button>
    `);
  }
}

// Extract text from PDF using PDF.js
async function extractPdfText(arrayBuffer) {
  if (typeof pdfjsLib === 'undefined') {
    throw new Error('PDF.js library not loaded');
  }
  
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  const numPages = pdf.numPages;
  
  let textChunks = [];
  
  // Extract text from all pages
  for (let pageNum = 1; pageNum <= numPages; pageNum++) {
    const page = await pdf.getPage(pageNum);
    const textContent = await page.getTextContent();
    const pageText = textContent.items.map(item => item.str).join(' ');
    textChunks.push(pageText);
  }
  
  const fullText = textChunks.join('\n\n');
  
  // Return text with page count info
  return fullText || '[PDF contains no extractable text - may be scanned/image-based]';
}

// NEW: Analyze files with AI assistant instead of auto-hashing
async function analyzeFilesWithAI(files, userText = '') {
  addMessage(`<p>‚è≥ Analyzing ${files.length} document(s)...</p>`);
  
  try {
    // Read file content (for text files) or get metadata
    let fileContent = '';
    let fileInfo = [];
    
    for (const file of files) {
      const info = {
        name: file.name,
        size: file.size,
        type: file.type,
        file: file // Keep reference for later
      };
      
      // If text-based file, read content
      if (file.type.includes('text') || file.name.endsWith('.txt') || file.name.endsWith('.md') || file.name.endsWith('.json')) {
        const content = await file.text();
        info.content = content;
        fileContent += `\n\n--- ${file.name} ---\n${content}`;
      } else if (file.type.includes('pdf') || file.name.toLowerCase().endsWith('.pdf')) {
        // Extract PDF text using PDF.js
        try {
          const arrayBuffer = await file.arrayBuffer();
          const pdfText = await extractPdfText(arrayBuffer);
          info.content = pdfText;
          fileContent += `\n\n--- ${file.name} ---\n${pdfText}`;
        } catch (e) {
          console.error('PDF extraction failed:', e);
          info.content = '[PDF - text extraction failed: ' + e.message + ']';
        }
      } else {
        info.content = '[Binary file]';
      }
      
      fileInfo.push(info);
    }
    
    // Store context for follow-up questions
    lastAnalyzedFile = {
      files: fileInfo,
      content: fileContent,
      analyzedAt: new Date().toISOString()
    };
    
    // Build conversational response
    const file = fileInfo[0];
    const fileName = file.name.toLowerCase();
    
    // LISTENING FIRST - acknowledge and invite their story
    let response = `<p><strong>Right, I've got your file.</strong></p>`;
    response += `<p><strong>${file.name}</strong> ‚Ä¢ ${(file.size / 1024).toFixed(1)} KB</p>`;
    response += `<p>Before I dig into it ‚Äî want to tell me what's going on? Why are you uploading this?</p>`;
    response += `<p><em>Just type it out: "The bank ignored my affidavit" or "This invoice looks dodgy" or whatever. I'm listening.</em></p>`;
    
    // Classification (for context, shown after they explain)
    let classification = 'document';
    let classificationConfidence = 'appears to be';
    
    if (fileContent.length > 0) {
      const lower = fileContent.toLowerCase();
      if (lower.includes('affidavit') || lower.includes('sworn statement')) {
        classification = 'legal affidavit';
        classificationConfidence = 'is';
      } else if (lower.includes('contract') || lower.includes('agreement')) {
        classification = 'legal contract or agreement';
      } else if (lower.includes('invoice') || lower.includes('receipt')) {
        classification = 'financial record (invoice/receipt)';
      } else if (lower.includes('complaint') || lower.includes('plaintiff')) {
        classification = 'legal complaint or filing';
      } else if (lower.includes('policy') || lower.includes('terms and conditions')) {
        classification = 'policy document';
      } else if (lower.includes('evidence') || lower.includes('exhibit')) {
        classification = 'legal evidence or exhibit';
      } else {
        classification = 'text document';
      }
    } else if (file.type === 'application/pdf') {
      // Filename-based classification for PDFs
      if (fileName.includes('affidavit')) {
        classification = 'legal affidavit (PDF)';
      } else if (fileName.includes('contract') || fileName.includes('agreement')) {
        classification = 'legal contract (PDF)';
      } else if (fileName.includes('doc') || fileName.includes('legal')) {
        classification = 'legal/administrative PDF';
      } else if (fileName.includes('invoice') || fileName.includes('receipt')) {
        classification = 'financial document (PDF)';
      } else {
        classification = 'PDF document';
      }
    }
    
    // Show classification but don't dominate the message
    response += `<p style="margin-top:12px;font-size:0.95em;color:var(--muted)"><em>(Looks like a <strong>${classification}</strong>)</em></p>`;
    
    // Calculate hash for action buttons (but don't push them yet - listen first)
    const arrayBuffer = await file.file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Add action buttons at the bottom (optional, after they explain)
    response += `
      <p style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border)"><strong>Or skip straight to:</strong></p>
      <button class="inline-btn" onclick="showHashDetails('${hash}', '${file.name}')">üîç View Hash</button>
      <button class="inline-btn" onclick="sealDocument('${hash}', '${file.name}')">üìú Seal It</button>
      <button class="inline-btn" onclick="anchorHash('${hash}')">üîó Anchor It</button>
    `;
    
    addMessage(response);
    
  } catch (e) {
    addMessage(`<p>‚ùå Error analyzing document: ${e.message}</p>`);
    console.error('File analysis error:', e);
  }
}

// Show hash details (replaces hashAndOfferActions)
window.showHashDetails = function(hash, filename) {
  addMessage(`
    <p>‚úÖ <strong>${filename}</strong></p>
    <p><strong>SHA-512 Hash:</strong></p>
    <code style="word-break:break-all;font-size:0.85em;display:block;background:var(--bg);padding:8px;border-radius:4px">${hash}</code>
    <p>This hash is a unique cryptographic fingerprint of your document. Any modification will change it.</p>
  `);
}

async function anchorHash(hash) {
  addMessage(`<p>‚è≥ Anchoring hash to blockchain...</p>`);
  
  try {
    console.log('Anchoring hash:', hash, 'to', BASE + '/v1/anchor');
    const r = await fetch(BASE + '/v1/anchor', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ hash })
    });
    
    if (!r.ok) {
      const errorText = await r.text();
      throw new Error(`HTTP ${r.status}: ${errorText}`);
    }
    
    const data = await r.json();
    if (data.ok) {
      addMessage(`
        <p>‚úÖ Hash anchored successfully!</p>
        <p><strong>Receipt:</strong></p>
        <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em">${JSON.stringify(data, null, 2)}</pre>
      `);
    } else {
      addMessage(`<p>‚ùå Anchor failed: ${data.error}</p>`);
    }
  } catch (e) {
    addMessage(`<p>‚ùå Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/anchor</p>`);
    console.error('Anchor error:', e);
  }
}

async function sealDocument(hash, filename) {
  addMessage(`<p>‚è≥ Generating forensic seal PDF...</p>`);
  
  try {
    console.log('Sealing document:', filename, 'hash:', hash, 'to', BASE + '/v1/seal');
    const r = await fetch(BASE + '/v1/seal', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        hash, 
        title: filename || 'Document Seal',
        notes: 'Generated via Verum Assistant'
      })
    });
    
    if (r.ok) {
      const blob = await r.blob();
      const url = URL.createObjectURL(blob);
      addMessage(`
        <p>‚úÖ Seal PDF generated!</p>
        <a href="${url}" download="verum-seal-${hash.substring(0, 8)}.pdf" class="inline-btn">‚¨áÔ∏è Download Sealed PDF</a>
      `);
    } else {
      const err = await r.text();
      addMessage(`<p>‚ùå Seal generation failed (HTTP ${r.status}): ${err}</p>`);
    }
  } catch (e) {
    addMessage(`<p>‚ùå Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/seal</p>`);
    console.error('Seal error:', e);
  }
}

async function handleTextMessage(text) {
  const lower = text.toLowerCase();
  
  // Check for actions on uploaded document
  if (lastAnalyzedFile) {
    
    // REFLECT BACK: If they're explaining their situation, acknowledge it
    const storyKeywords = ['bank', 'court', 'lawyer', 'judge', 'fraud', 'scam', 'ignored', 'refused', 'denied', 
                          'lied', 'altered', 'forged', 'fake', 'wrong', 'incorrect', 'dispute', 'problem'];
    const hasStoryContext = storyKeywords.some(keyword => lower.includes(keyword));
    
    if (hasStoryContext && text.length > 20 && !lower.includes('seal') && !lower.includes('anchor')) {
      // They're telling their story - reflect it back
      addMessage(`
        <p><strong>Okay, I hear you.</strong></p>
        <p>You're saying: <em>"${text}"</em></p>
        <p>Right. Let me look at <strong>${lastAnalyzedFile.files[0].name}</strong> against that.</p>
        <p>What do you want me to do with it?</p>
        <ul>
          <li><strong>"Seal it"</strong> ‚Äî Lock this version down so no one can claim it was different</li>
          <li><strong>"Check for fraud"</strong> ‚Äî I'll scan for dodgy patterns or contradictions</li>
          <li><strong>"Summarize it"</strong> ‚Äî I'll extract the key info and explain what it says</li>
          <li><strong>"Anchor it"</strong> ‚Äî Timestamp it on blockchain for proof</li>
        </ul>
      `);
      return;
    }
    
    // Seal/hash commands
    if (lower.includes('seal') || lower.includes('seal it') || lower.includes('generate seal')) {
      const file = lastAnalyzedFile.files[0];
      const arrayBuffer = await file.file.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      await sealDocument(hash, file.name);
      return;
    }
    
    // Anchor commands
    if (lower.includes('anchor') || lower.includes('blockchain')) {
      const file = lastAnalyzedFile.files[0];
      const arrayBuffer = await file.file.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      await anchorHash(hash);
      return;
    }
    
    // Summarize/explain commands
    if (lower.includes('summarize') || lower.includes('explain') || lower.includes('what does it say')) {
      const file = lastAnalyzedFile.files[0];
      if (lastAnalyzedFile.content && lastAnalyzedFile.content.trim().length > 0) {
        const preview = lastAnalyzedFile.content.substring(0, 1000);
        addMessage(`
          <p><strong>üìÑ Document Summary</strong></p>
          <p><strong>File:</strong> ${file.name}</p>
          <p><strong>Content preview (first 1000 chars):</strong></p>
          <pre style="background:var(--bg);padding:12px;border-radius:4px;font-size:0.9em;max-height:300px;overflow:auto;white-space:pre-wrap">${preview}${lastAnalyzedFile.content.length > 1000 ? '...' : ''}</pre>
          <p><em>This is raw text extraction. For deeper analysis, I would need server-side PDF parsing capabilities.</em></p>
        `);
      } else {
        addMessage(`
          <p><strong>üìÑ Cannot Summarize PDF</strong></p>
          <p>This is a PDF file and I cannot extract text content in the browser. To analyze the content, I would need:</p>
          <ul>
            <li>Server-side PDF parsing (not yet implemented)</li>
            <li>Or you can describe what the document contains</li>
          </ul>
          <p>I can still create a forensic seal, hash, or blockchain anchor for verification purposes.</p>
        `);
      }
      return;
    }
    
    // Check/investigate commands
    if (lower.includes('check') || lower.includes('investigate') || lower.includes('contradict') || lower.includes('fraud')) {
      addMessage(`
        <p><strong>Right, let's dig into it.</strong></p>
        <p>Here's what I can check:</p>
        <ul>
          <li><strong>Metadata</strong> ‚Äî When it was created, by whom, with what software</li>
          <li><strong>Contradictions</strong> ‚Äî Needs text content and something to compare it against</li>
          <li><strong>Hash fingerprint</strong> ‚Äî SHA-512 cryptographic signature</li>
          <li><strong>Tampering</strong> ‚Äî Compare current version against a known-good hash</li>
        </ul>
        <p><em>Want me to run the full forensic check? Just say "yes" or hit the buttons.</em></p>
      `);
      return;
    }
  }
  
  // Check if user is asking about the uploaded document
  if (lastAnalyzedFile && (
    lower.includes('what is') || 
    lower.includes('what\'s') || 
    lower.includes('tell me about') ||
    lower.includes('describe') ||
    lower.includes('analyze') ||
    lower.includes('read') ||
    lower.includes('summarize') ||
    lower.includes('the document') ||
    lower.includes('this document') ||
    lower.includes('the file') ||
    lower.includes('this file') ||
    lower === 'this' ||
    lower === 'that'
  )) {
    const file = lastAnalyzedFile.files[0];
    let response = `<p>You uploaded <strong>${file.name}</strong> (${(file.size / 1024).toFixed(1)} KB) `;
    
    if (lastAnalyzedFile.content && lastAnalyzedFile.content.trim().length > 0 && 
        !lastAnalyzedFile.content.includes('[PDF contains no extractable text')) {
      response += `and I've read it. Here's what I found:</p>`;
      
      const content = lastAnalyzedFile.content.toLowerCase();
      
      // Detailed analysis based on content
      if (content.includes('contract') || content.includes('agreement')) {
        response += `<p>üìÑ <strong>Document Type:</strong> Legal Contract or Agreement</p>
        <p>This appears to be a legal document that may contain binding obligations. I can help you:</p>
        <ul>
          <li>Create a tamper-proof sealed copy to prove the document existed at this time</li>
          <li>Generate a SHA-512 hash for verification purposes</li>
          <li>Anchor it to blockchain for permanent timestamped proof</li>
        </ul>
        <p><em>Would you like me to seal this document or create a verification hash?</em></p>`;
      } else if (content.includes('invoice') || content.includes('receipt') || content.includes('payment')) {
        response += `<p>üí∞ <strong>Document Type:</strong> Financial Record</p>
        <p>This looks like a financial document. Creating a sealed version ensures the amounts and dates can't be disputed later.</p>`;
      } else {
        response += `<p>üìù <strong>Document Type:</strong> Text Document</p>
        <p>Content preview (first 300 chars):</p>
        <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em;max-height:150px;overflow:auto">${lastAnalyzedFile.content.substring(0, 300)}...</pre>`;
      }
    } else if (lastAnalyzedFile.content && lastAnalyzedFile.content.includes('[PDF contains no extractable text')) {
      response += `but it looks like a scanned PDF (image-based). I can't extract text from images yet.</p>
      <p><strong>What I can still do:</strong></p>
      <ul>
        <li>Generate a SHA-512 hash to fingerprint it</li>
        <li>Create a sealed PDF certificate with watermarks</li>
        <li>Anchor the hash to blockchain for permanent proof</li>
      </ul>
      <p><em>Tell me what type of document it is (e.g., "it's a legal contract") and I can give you better advice. Or just say "seal it" and I'll make it tamper-proof.</em></p>`;
    } else {
      response += `but I couldn't extract the text. This might be a scanned/image-based PDF or a binary file.</p>
      <p><strong>But here's what I know:</strong></p>
      <ul>
        <li>Name: ${file.name}</li>
        <li>Size: ${(file.size / 1024).toFixed(1)} KB</li>
        <li>Type: ${file.type || 'Unknown'}</li>
      </ul>
      <p><strong>What I can do right now:</strong></p>
      <ul>
        <li>Generate a SHA-512 hash to fingerprint it</li>
        <li>Create a sealed PDF certificate with watermarks</li>
        <li>Anchor the hash to blockchain for permanent proof</li>
      </ul>
      <p><em>Tell me what type of document it is (e.g., "it's a legal contract") and I can give you better advice. Or just say "seal it" and I'll make it tamper-proof.</em></p>`;
    }
    
    addMessage(response);
    return;
  }
  
  // Check for contradiction detection request
  if (lower.includes('contradict') || lower.includes('check') || lower.includes('verify text')) {
    addMessage(`<p>‚è≥ Right, scanning this for contradictions...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/contradict', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text, meta: {}, timeline: [] })
      });
      
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      
      const data = await r.json();
      if (data.ok) {
        const findings = data.result.findings || [];
        if (findings.length === 0) {
          addMessage(`<p>‚úÖ Looks clean. No contradictions found.</p>`);
        } else {
          addMessage(`
            <p>‚ö†Ô∏è Hold on ‚Äî found ${findings.length} dodgy ${findings.length === 1 ? 'bit' : 'bits'}:</p>
            <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em">${JSON.stringify(findings, null, 2)}</pre>
          `);
        }
      }
    } catch (e) {
      addMessage(`<p>‚ùå Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/contradict</p>`);
      console.error('Contradict API error:', e);
    }
    return;
  }
  
  // Check for constitution/policy request
  if (lower.includes('constitution') || lower.includes('policy') || lower.includes('rules')) {
    addMessage(`<p>‚è≥ Fetching constitutional policy...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/assistant', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mode: 'policy' })
      });
      
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      
      const data = await r.json();
      if (data.ok) {
        addMessage(`
          <p>‚úÖ Constitution retrieved:</p>
          <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em;max-height:300px;overflow:auto">${JSON.stringify(data.constitution, null, 2)}</pre>
          <p><strong>Manifest version:</strong> ${data.manifest.version}</p>
        `);
      }
    } catch (e) {
      addMessage(`<p>‚ùå Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/assistant</p>`);
      console.error('Policy API error:', e);
    }
    return;
  }
  
  // Check for licensing/pricing info
  if (lower.includes('price') || lower.includes('cost') || lower.includes('free') || lower.includes('licensing')) {
    addMessage(`<p>‚è≥ Fetching licensing information...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/notice');
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      const data = await r.json();
      if (data.ok) {
        addMessage(`
          <p>üí∞ <strong>Licensing Terms:</strong></p>
          <p><strong>Citizens:</strong> ${data.notice.citizen}</p>
          <p><strong>Institutions:</strong> ${data.notice.institution}</p>
        `);
      }
    } catch (e) {
      addMessage(`<p>‚ùå Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/notice</p>`);
      console.error('Notice API error:', e);
    }
    return;
  }
  
  // Natural conversational responses
  if (lower.includes('how are you') || lower.includes('how r u') || lower.includes('how do you do')) {
    const responses = [
      `<p>All good. What've you got?</p>`,
      `<p>Yeah, I'm good. Need something verified?</p>`,
      `<p>Doing alright. What's up?</p>`
    ];
    addMessage(responses[Math.floor(Math.random() * responses.length)]);
    return;
  }
  
  if (lower.includes('who are you') || lower.includes('what are you') || lower.includes('tell me about yourself')) {
    addMessage(`<p>I'm Verum Omnis ‚Äî a forensic firewall against lies, fraud, and manipulation.</p>
      <p>I catch contradictions, verify documents, and seal them so no one can tamper with them. Upload something dodgy and I'll tell you exactly what's wrong with it.</p>`);
    return;
  }
  
  if (lower.includes('thank') || lower.includes('thanks')) {
    const responses = [
      `<p>You're welcome! Happy to help.</p>`,
      `<p>Anytime. That's what I'm here for.</p>`,
      `<p>No problem! Come back if you need anything else.</p>`,
      `<p>Glad I could help. I'm always here.</p>`
    ];
    addMessage(responses[Math.floor(Math.random() * responses.length)]);
    return;
  }
  
  // Greetings - just be normal
  if (lower.match(/^(hello|hi|hey|greetings|yo|sup)(\s+(there|everyone|friend|mate))?$/i) || 
      lower.match(/^good\s+(morning|afternoon|evening|day)$/i) ||
      lower.match(/^(whats?\s*up|howdy)$/i)) {
    const greetings = [
      `<p>Alright, what've you got for me?</p>`,
      `<p>Hey. Upload a document or just ask me something.</p>`,
      `<p>What's up? Got something dodgy you need checked?</p>`,
      `<p>Right, let's see what you've got.</p>`
    ];
    addMessage(greetings[Math.floor(Math.random() * greetings.length)]);
    return;
  }
  
  // Help/capabilities
  if (lower.includes('what can you do') || lower.includes('how do you work') || lower.includes('help me') || lower.includes('help') ||
      lower.includes('can you read') || lower.includes('can you analyze') || lower.includes('do you read') ||
      lower.includes('can you check') || lower.includes('are you able')) {
    addMessage(`<p>Yeah, I can read documents. Upload one and I'll tell you what it says.</p>
      <p>Here's what I do:</p>
      <ul>
        <li>Analyze documents ‚Äî PDFs, text files, images with text, whatever</li>
        <li>Tell you if something looks dodgy or has contradictions</li>
        <li>Seal them with forensic-grade PDFs (SHA-512, watermarks, QR codes ‚Äî the full kit)</li>
        <li>Anchor hashes so they're timestamped and tamper-proof</li>
        <li>Explain everything in plain English before I do anything</li>
      </ul>
      <p>Upload a file and I'll walk you through it. No jargon, no bullshit.</p>`);
    return;
  }
  
  // Test API connection only if specifically asked
  if (lower.includes('test api') || lower.includes('check connection')) {
    addMessage(`<p>‚è≥ Testing API connection...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/verify');
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      const data = await r.json();
      addMessage(`
        <p>‚úÖ <strong>API Connected!</strong></p>
        <p>Pack: ${data.pack}</p>
        <p>Time: ${data.time}</p>
        <p style="font-size:0.85em;color:var(--muted)">Endpoint: ${BASE}</p>
      `);
    } catch (e) {
      addMessage(`<p>‚ùå API Connection Failed: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">Endpoint: ${BASE}/v1/verify</p>`);
      console.error('API test error:', e);
    }
    return;
  }
  
  // Default: Natural conversational fallback
  const responses = [
    `<p>Not sure what you're asking. Upload a document or ask me something like:</p>
     <ul>
       <li>"Can you read this file?"</li>
       <li>"Check for contradictions"</li>
       <li>"Seal it"</li>
       <li>"What can you do?"</li>
     </ul>`,
    
    `<p>I'm not following. Want to upload something? Or just ask:</p>
     <ul>
       <li>"What do you do?"</li>
       <li>"How do I verify a document?"</li>
       <li>"Can you analyze PDFs?"</li>
     </ul>`,
    
    `<p>Hmm, I need a bit more. Try:</p>
     <ul>
       <li>Upload a document (üìé button)</li>
       <li>Ask "What can you do?"</li>
       <li>Say "Seal this file" or "Check for fraud"</li>
     </ul>`
  ];
  
  // Pick a random helpful response
  const randomResponse = responses[Math.floor(Math.random() * responses.length)];
  addMessage(randomResponse);
}

async function sendMessage() {
  const text = userInput.value.trim();
  
  if (!text && uploadedFiles.length === 0) return;
  
  // Show user message
  if (text) {
    addMessage(`<p>${text}</p>`, true);
  }
  
  if (uploadedFiles.length > 0) {
    addMessage(`<p>üìé Attached ${uploadedFiles.length} file(s)</p>`, true);
  }
  
  userInput.value = '';
  
  // If files uploaded, send to AI assistant for analysis
  if (uploadedFiles.length > 0) {
    await analyzeFilesWithAI(uploadedFiles, text);
    uploadedFiles = [];
    uploadedFilesDiv.innerHTML = '';
    fileInput.value = '';
  } else if (text) {
    // Just text, no files
    await handleTextMessage(text);
  }
}

// Voice input setup
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = 'en-US';
  
  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    userInput.value = transcript;
    isListening = false;
    updateVoiceButton();
  };
  
  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
    isListening = false;
    updateVoiceButton();
    
    let errorMsg = 'Voice input error';
    if (event.error === 'not-allowed' || event.error === 'permission-denied') {
      errorMsg = 'Microphone permission denied. Please enable microphone access.';
    } else if (event.error === 'no-speech') {
      errorMsg = 'No speech detected. Please try again.';
    } else if (event.error === 'network') {
      errorMsg = 'Network error. Please check your connection.';
    }
    
    showToast('‚ùå ' + errorMsg);
  };
  
  recognition.onend = () => {
    isListening = false;
    updateVoiceButton();
  };
} else {
  // Hide voice button if not supported
  document.getElementById('voiceBtn').style.display = 'none';
}

function toggleVoiceInput() {
  if (!recognition) return;
  
  if (isListening) {
    recognition.stop();
    isListening = false;
  } else {
    recognition.start();
    isListening = true;
    showToast('üé§ Listening...');
  }
  updateVoiceButton();
}

function updateVoiceButton() {
  const btn = document.getElementById('voiceBtn');
  if (btn) {
    btn.textContent = isListening ? 'üî¥' : 'üé§';
    btn.style.background = isListening ? '#ef4444' : '';
  }
}

// Export conversation to PDF
async function exportConversation() {
  showToast('üìÑ Generating PDF...');
  
  // Calculate hash of entire conversation
  const conversationText = conversationHistory.map(m => m.html.replace(/<[^>]*>/g, '')).join('\n\n');
  const encoder = new TextEncoder();
  const data = encoder.encode(conversationText);
  const hashBuffer = await crypto.subtle.digest('SHA-512', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  
  try {
    const r = await fetch(BASE + '/v1/seal', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        hash, 
        title: 'Verum Conversation Export',
        notes: `Exported ${new Date().toISOString()} - ${conversationHistory.length} messages`
      })
    });
    
    if (r.ok) {
      const blob = await r.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `verum-conversation-${hash.substring(0, 8)}.pdf`;
      a.click();
      showToast('‚úÖ PDF downloaded');
    } else {
      showToast('‚ùå Export failed');
    }
  } catch (e) {
    showToast('‚ùå Error: ' + e.message);
  }
}

// Enter key to send
userInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

// Don't show welcome message - keep chat clean and empty initially
// Users can start by uploading documents or asking questions

// Explicitly expose functions to global scope for onclick handlers
window.sendMessage = sendMessage;
window.toggleTheme = toggleTheme;
window.exportConversation = exportConversation;
window.clearHistory = clearHistory;
window.toggleVoiceInput = toggleVoiceInput;

// Also attach event listeners directly (backup for onclick)
document.addEventListener('DOMContentLoaded', () => {
  // Send button
  const sendBtn = document.querySelector('.chat-btn-send');
  if (sendBtn) {
    sendBtn.addEventListener('click', (e) => {
      e.preventDefault();
      sendMessage();
    });
  }
  
  // Theme toggle
  const themeBtn = document.getElementById('themeBtn');
  if (themeBtn) {
    themeBtn.addEventListener('click', (e) => {
      e.preventDefault();
      toggleTheme();
    });
  }
  
  // Export button
  const exportBtn = document.getElementById('exportBtn');
  if (exportBtn) {
    exportBtn.addEventListener('click', (e) => {
      e.preventDefault();
      exportConversation();
    });
  }
  
  // Clear history button
  const clearBtn = document.getElementById('clearBtn');
  if (clearBtn) {
    clearBtn.addEventListener('click', (e) => {
      e.preventDefault();
      clearHistory();
    });
  }
  
  // Voice button
  const voiceBtn = document.getElementById('voiceBtn');
  if (voiceBtn) {
    voiceBtn.addEventListener('click', (e) => {
      e.preventDefault();
      toggleVoiceInput();
    });
  }
});
</script>

</body></html>
