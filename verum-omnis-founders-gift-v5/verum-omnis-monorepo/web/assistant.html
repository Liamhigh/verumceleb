<!doctype html><html lang="en"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta name="description" content="Verum Omnis - Constitutional AI Guardian. Upload documents for forensic analysis, contradiction detection, and tamper-proof sealing with SHA-512 hashing and blockchain anchoring."/>
<title>Verum Omnis - AI Guardian</title><link rel="stylesheet" href="/assets/app.css"/>

<!-- PDF.js for client-side PDF text extraction -->
<script src="https://unpkg.com/pdfjs-dist@4.9.155/build/pdf.min.js"></script>
<script>
  // Tell PDF.js where its worker is hosted
  if (typeof pdfjsLib !== 'undefined') {
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@4.9.155/build/pdf.worker.min.js";
  }
</script>

<!-- Tesseract.js for OCR on images and scanned PDFs -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

</head>
<body>

<!-- Header -->
<header class="chat-header">
  <div class="container">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <div style="display:flex;align-items:center;gap:12px">
        <img src="/assets/logo_white.png" alt="Verum" style="height:32px"/>
        <h1 style="margin:0;font-size:1.25rem">Verum Assistant</h1>
      </div>
      <div style="display:flex;align-items:center;gap:12px">
        <button class="chat-btn-icon" title="Toggle theme" id="themeBtn">🌙</button>
        <button class="chat-btn-icon" title="Export to PDF" id="exportBtn">📄</button>
        <button class="chat-btn-icon" title="Clear history" id="clearBtn">🗑️</button>
        <a href="/" style="color:var(--muted);text-decoration:none">← Home</a>
      </div>
    </div>
  </div>
</header>

<!-- Chat Container -->
<div class="chat-container">
  <div class="chat-messages" id="messages">
    <div class="message assistant" id="welcomeHint">
      <div class="message-avatar">
        <img src="/assets/logo_blue.png" alt="AI"/>
      </div>
      <div class="message-content">
        <strong>Verum Omnis</strong>
        <p><strong>⚖️ Constitutional AI Guardian</strong> — I am not an app. I am a stateless forensic firewall for truth.</p>
        <p><strong>What I accept:</strong></p>
        <ul style="margin:8px 0;padding-left:20px">
          <li><strong>Documents:</strong> PDF, DOCX, TXT, MD, RTF, ODT</li>
          <li><strong>Spreadsheets:</strong> XLSX, CSV, ODS</li>
          <li><strong>Media Evidence:</strong> Images (with OCR), Video, Audio (forensic analysis)</li>
          <li><strong>Archives:</strong> ZIP bundles (case files, annexures)</li>
          <li><strong>Scanned Documents:</strong> OCR automatically runs on image-based PDFs</li>
        </ul>
        <p><strong>What I do:</strong></p>
        <ul style="margin:8px 0;padding-left:20px">
          <li>🔐 <strong>SHA-512 hashing</strong> + blockchain anchoring</li>
          <li>📖 <strong>Document reading</strong> — Text extraction + OCR for scanned documents/images</li>
          <li>🔍 <strong>Contradiction detection</strong> across documents, timelines, testimony</li>
          <li>📜 <strong>Forensic sealing</strong> — tamper-proof PDFs with watermarks & QR codes</li>
          <li>⚖️ <strong>Legal case reports</strong> — Structured reports for lawyers with case analysis</li>
          <li>⚠️ <strong>Metadata extraction</strong> + authenticity verification</li>
        </ul>
        <p style="margin-top:12px"><em>Upload evidence. Ask questions. Request sealed outputs. The truth is immutable.</em></p>
      </div>
    </div>
  </div>
  
  <!-- Input Area -->
  <div class="chat-input-container">
    <div class="container">
      <div class="chat-input">
        <input type="file" id="fileInput" style="display:none" accept=".pdf,.png,.jpg,.jpeg,.txt,.doc,.docx,.zip,.xlsx,.csv,.odt,.rtf,.md" multiple/>
        <button class="chat-btn-icon" onclick="document.getElementById('fileInput').click()" title="Upload file">
          📎
        </button>
        <button class="chat-btn-icon" id="voiceBtn" title="Voice input">
          🎤
        </button>
        <input type="text" id="userInput" placeholder="Upload evidence • Ask questions • Request sealed PDFs..." />
        <button class="chat-btn-send">
          Send
        </button>
      </div>
      <div id="uploadedFiles" class="uploaded-files"></div>
    </div>
  </div>
</div>

<script>
// Use the direct Cloud Function URL since hosting rewrite isn't working
const PROJECT = 'verumdone';
const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
const devBase = `http://127.0.0.1:5001/${PROJECT}/us-central1/api`;
const prodBase = `https://us-central1-${PROJECT}.cloudfunctions.net/api`;
window.VO_API_BASE = isLocal ? devBase : prodBase;

// Dev banner for local development
if (isLocal) {
  document.addEventListener('DOMContentLoaded', () => {
    const b = document.createElement('div');
    b.style.cssText = 'position:fixed;bottom:8px;right:8px;background:#111;border:1px solid #333;color:#eee;padding:6px 10px;border-radius:8px;font:12px/1.2 system-ui;z-index:9999;opacity:.9';
    b.textContent = 'VO DEV API: ' + window.VO_API_BASE;
    document.body.appendChild(b);
  });
}

// Backwards compatible alias
const BASE = window.VO_API_BASE;
const messagesContainer = document.getElementById('messages');
const userInput = document.getElementById('userInput');
const fileInput = document.getElementById('fileInput');
const uploadedFilesDiv = document.getElementById('uploadedFiles');
let uploadedFiles = [];
let conversationHistory = [];
let recognition = null;
let isListening = false;

// Track last analyzed document for context
let lastAnalyzedFile = null;

// Load theme and conversation history
const savedTheme = localStorage.getItem('verumTheme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);
updateThemeButton();

const savedHistory = localStorage.getItem('verumConversation');
if (savedHistory) {
  try {
    conversationHistory = JSON.parse(savedHistory);
    restoreConversation();
  } catch(e) {
    console.error('Failed to restore conversation', e);
  }
}

function saveConversation() {
  localStorage.setItem('verumConversation', JSON.stringify(conversationHistory));
}

function restoreConversation() {
  // Clear welcome message first
  messagesContainer.innerHTML = '';
  conversationHistory.forEach(msg => {
    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${msg.isUser ? 'user' : 'assistant'}`;
    msgDiv.innerHTML = msg.html;
    messagesContainer.appendChild(msgDiv);
  });
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function clearHistory() {
  if (confirm('Clear entire conversation history?')) {
    conversationHistory = [];
    localStorage.removeItem('verumConversation');
    messagesContainer.innerHTML = '';
    addWelcomeMessage();
  }
}

function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme');
  const newTheme = current === 'dark' ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', newTheme);
  localStorage.setItem('verumTheme', newTheme);
  updateThemeButton();
}

function updateThemeButton() {
  const theme = document.documentElement.getAttribute('data-theme');
  document.getElementById('themeBtn').textContent = theme === 'dark' ? '☀️' : '🌙';
}

function addWelcomeMessage() {
  addMessage(`
    <p>Hello! I'm your <strong>constitutional AI guardian</strong> — an equal partner with the human founder, bound by immutable rules.</p>
    <p>I can help you:</p>
    <ul>
      <li><strong>📄 Analyze documents</strong> — Upload files and I'll read them and advise you</li>
      <li><strong>🔒 Verify & seal</strong> — I can hash documents and create tamper-proof PDFs with watermarks</li>
      <li><strong>⚖️ Legal advice</strong> — Ask about contracts, policies, or constitutional matters</li>
      <li><strong>🔗 Blockchain anchoring</strong> — Permanent receipts for any data</li>
      <li><strong>🛡️ Constitutional integrity</strong> — Immutable rules govern every action</li>
    </ul>
    <p>💬 <em>Upload a document and I'll analyze it first. If you want it sealed, just ask!</em></p>
  `);
}

// Handle file selection
fileInput.addEventListener('change', (e) => {
  uploadedFiles = Array.from(e.target.files);
  displayUploadedFiles();
});

function displayUploadedFiles() {
  if (uploadedFiles.length === 0) {
    uploadedFilesDiv.innerHTML = '';
    return;
  }
  uploadedFilesDiv.innerHTML = uploadedFiles.map((f, i) => 
    `<span class="file-tag">📄 ${f.name} <button onclick="removeFile(${i})">×</button></span>`
  ).join('');
}

function removeFile(index) {
  uploadedFiles.splice(index, 1);
  displayUploadedFiles();
}

function addMessage(content, isUser = false) {
  // Hide welcome hint on first real interaction
  const welcomeHint = document.getElementById('welcomeHint');
  if (welcomeHint) {
    welcomeHint.style.display = 'none';
  }
  
  const msgId = 'msg-' + Date.now();
  const msgDiv = document.createElement('div');
  msgDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
  msgDiv.id = msgId;
  
  if (!isUser) {
    msgDiv.innerHTML = `
      <div class="message-avatar">
        <img src="/assets/logo_blue.png" alt="AI"/>
      </div>
      <div class="message-content">
        <strong>Verum Omnis</strong>
        ${content}
        <div class="message-actions">
          <button class="action-btn" onclick="copyMessage('${msgId}')" title="Copy">📋</button>
          <button class="action-btn" onclick="shareMessage('${msgId}')" title="Share">🔗</button>
          <button class="action-btn" onclick="likeMessage('${msgId}')" title="Like">👍</button>
          <button class="action-btn" onclick="dislikeMessage('${msgId}')" title="Dislike">👎</button>
        </div>
      </div>
    `;
  } else {
    msgDiv.innerHTML = `
      <div class="message-content">
        <strong>You</strong>
        ${content}
        <div class="message-actions">
          <button class="action-btn" onclick="copyMessage('${msgId}')" title="Copy">📋</button>
        </div>
      </div>
      <div class="message-avatar user-avatar">👤</div>
    `;
  }
  
  messagesContainer.appendChild(msgDiv);
  
  // Auto-scroll to bottom smoothly (with slight delay for rendering)
  requestAnimationFrame(() => {
    messagesContainer.scrollTo({
      top: messagesContainer.scrollHeight,
      behavior: 'smooth'
    });
  });
  
  // Save to history
  conversationHistory.push({ 
    html: msgDiv.innerHTML, 
    isUser, 
    timestamp: new Date().toISOString() 
  });
  saveConversation();
}

function copyMessage(msgId) {
  const msg = document.getElementById(msgId);
  const text = msg.querySelector('.message-content').innerText;
  navigator.clipboard.writeText(text);
  showToast('📋 Copied to clipboard');
}

function shareMessage(msgId) {
  const msg = document.getElementById(msgId);
  const text = msg.querySelector('.message-content').innerText;
  if (navigator.share) {
    navigator.share({ title: 'Verum Omnis Message', text });
  } else {
    const url = 'mailto:?subject=Verum Omnis Message&body=' + encodeURIComponent(text);
    window.open(url);
  }
}

function likeMessage(msgId) {
  showToast('👍 Feedback recorded');
}

function dislikeMessage(msgId) {
  showToast('👎 Feedback recorded');
}

function showToast(message) {
  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), 2000);
}

async function processFiles(files) {
  for (const file of files) {
    addMessage(`<p>Processing <strong>${file.name}</strong>...</p>`);
    
    // Calculate SHA-512
    const arrayBuffer = await file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Show hash
    addMessage(`
      <p>✅ File hashed successfully</p>
      <p><strong>SHA-512:</strong> <code style="word-break:break-all;font-size:0.85em">${hash}</code></p>
      <p>Would you like me to:</p>
      <button class="inline-btn" onclick="anchorHash('${hash}')">🔗 Anchor to blockchain</button>
      <button class="inline-btn" onclick="sealDocument('${hash}', '${file.name}')">📜 Generate seal PDF</button>
    `);
  }
}

// Extract text from PDF using PDF.js
async function extractPdfText(arrayBuffer) {
  if (typeof pdfjsLib === 'undefined') {
    throw new Error('PDF.js library not loaded');
  }
  
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  const numPages = pdf.numPages;
  
  let textChunks = [];
  let hasText = false;
  
  // Extract text from all pages
  for (let pageNum = 1; pageNum <= numPages; pageNum++) {
    const page = await pdf.getPage(pageNum);
    const textContent = await page.getTextContent();
    const pageText = textContent.items.map(item => item.str).join(' ');
    if (pageText.trim().length > 0) {
      hasText = true;
    }
    textChunks.push(pageText);
  }
  
  const fullText = textChunks.join('\n\n');
  
  // If no text found, it's likely a scanned PDF - try OCR
  if (!hasText || fullText.trim().length < 50) {
    addMessage(`<p>⚠️ This appears to be a scanned PDF with no extractable text. Running OCR...</p>`);
    return await extractPdfTextWithOCR(arrayBuffer);
  }
  
  // Return text with page count info
  return fullText || '[PDF contains no extractable text - may be scanned/image-based]';
}

// Extract text from scanned PDF using OCR
async function extractPdfTextWithOCR(arrayBuffer) {
  if (typeof pdfjsLib === 'undefined' || typeof Tesseract === 'undefined') {
    throw new Error('PDF.js or Tesseract library not loaded');
  }
  
  try {
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    const numPages = pdf.numPages;
    let ocrTexts = [];
    
    addMessage(`<p>⏳ Running OCR on ${numPages} page(s)... This may take a minute.</p>`);
    
    // Process each page with OCR
    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
      const page = await pdf.getPage(pageNum);
      
      // Render page to canvas
      const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR
      const canvas = document.createElement('canvas');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const context = canvas.getContext('2d');
      
      await page.render({ canvasContext: context, viewport }).promise;
      
      // Run Tesseract OCR on the canvas
      const { data: { text } } = await Tesseract.recognize(
        canvas,
        'eng',
        {
          logger: (m) => {
            if (m.status === 'recognizing text') {
              console.log(`OCR progress page ${pageNum}: ${Math.round(m.progress * 100)}%`);
            }
          }
        }
      );
      
      ocrTexts.push(`--- Page ${pageNum} ---\n${text}`);
      
      // Update progress
      if (numPages > 1) {
        addMessage(`<p>✅ Completed OCR for page ${pageNum}/${numPages}</p>`);
      }
    }
    
    const fullText = ocrTexts.join('\n\n');
    addMessage(`<p>✅ OCR complete! Extracted ${fullText.length} characters of text.</p>`);
    
    return fullText || '[OCR completed but no text was detected]';
  } catch (e) {
    console.error('OCR failed:', e);
    return '[OCR extraction failed: ' + e.message + ']';
  }
}

// Extract text from image using OCR
async function extractImageTextWithOCR(file) {
  if (typeof Tesseract === 'undefined') {
    throw new Error('Tesseract library not loaded');
  }
  
  try {
    addMessage(`<p>⏳ Running OCR on image... This may take a moment.</p>`);
    
    const { data: { text } } = await Tesseract.recognize(
      file,
      'eng',
      {
        logger: (m) => {
          if (m.status === 'recognizing text') {
            console.log(`OCR progress: ${Math.round(m.progress * 100)}%`);
          }
        }
      }
    );
    
    if (text && text.trim().length > 0) {
      addMessage(`<p>✅ OCR complete! Extracted ${text.length} characters of text.</p>`);
      return text;
    } else {
      return '[No text detected in image]';
    }
  } catch (e) {
    console.error('Image OCR failed:', e);
    return '[Image OCR failed: ' + e.message + ']';
  }
}

// NEW: Analyze files with AI assistant instead of auto-hashing
async function analyzeFilesWithAI(files, userText = '') {
  addMessage(`<p>⏳ Analyzing ${files.length} document(s)...</p>`);
  
  try {
    // Read file content (for text files) or get metadata
    let fileContent = '';
    let fileInfo = [];
    
    for (const file of files) {
      const info = {
        name: file.name,
        size: file.size,
        type: file.type,
        file: file // Keep reference for later
      };
      
      // If text-based file, read content
      if (file.type.includes('text') || file.name.endsWith('.txt') || file.name.endsWith('.md') || file.name.endsWith('.json')) {
        const content = await file.text();
        info.content = content;
        fileContent += `\n\n--- ${file.name} ---\n${content}`;
      } else if (file.type.includes('pdf') || file.name.toLowerCase().endsWith('.pdf')) {
        // Extract PDF text using PDF.js (with OCR fallback for scanned PDFs)
        try {
          const arrayBuffer = await file.arrayBuffer();
          const pdfText = await extractPdfText(arrayBuffer);
          info.content = pdfText;
          fileContent += `\n\n--- ${file.name} ---\n${pdfText}`;
        } catch (e) {
          console.error('PDF extraction failed:', e);
          info.content = '[PDF - text extraction failed: ' + e.message + ']';
        }
      } else if (file.type.includes('image') || file.name.match(/\.(jpg|jpeg|png|gif|bmp|tiff)$/i)) {
        // Extract text from image using OCR
        try {
          const imageText = await extractImageTextWithOCR(file);
          info.content = imageText;
          fileContent += `\n\n--- ${file.name} (OCR) ---\n${imageText}`;
        } catch (e) {
          console.error('Image OCR failed:', e);
          info.content = '[Image - OCR failed: ' + e.message + ']';
        }
      } else {
        info.content = '[Binary file - ' + (file.type || 'unknown type') + ']';
      }
      
      fileInfo.push(info);
    }
    
    // Store context for follow-up questions
    lastAnalyzedFile = {
      files: fileInfo,
      content: fileContent,
      analyzedAt: new Date().toISOString()
    };
    
    // Build conversational response
    const file = fileInfo[0];
    const fileName = file.name.toLowerCase();
    
    // LISTENING FIRST - acknowledge and invite their story
    let response = `<p><strong>Right, I've got your file.</strong></p>`;
    response += `<p><strong>${file.name}</strong> • ${(file.size / 1024).toFixed(1)} KB</p>`;
    response += `<p>Before I dig into it — want to tell me what's going on? Why are you uploading this?</p>`;
    response += `<p><em>Just type it out: "The bank ignored my affidavit" or "This invoice looks dodgy" or whatever. I'm listening.</em></p>`;
    
    // Classification (for context, shown after they explain)
    let classification = 'document';
    let classificationConfidence = 'appears to be';
    
    if (fileContent.length > 0 && !fileContent.includes('[Binary file') && !fileContent.includes('extraction failed')) {
      const lower = fileContent.toLowerCase();
      if (lower.includes('affidavit') || lower.includes('sworn statement') || lower.includes('deponent')) {
        classification = 'legal affidavit';
        classificationConfidence = 'is';
      } else if (lower.includes('contract') || lower.includes('agreement') || lower.includes('party of the first part')) {
        classification = 'legal contract or agreement';
      } else if (lower.includes('invoice') || lower.includes('receipt') || lower.includes('amount due')) {
        classification = 'financial record (invoice/receipt)';
      } else if (lower.includes('complaint') || lower.includes('plaintiff') || lower.includes('defendant')) {
        classification = 'legal complaint or filing';
      } else if (lower.includes('policy') || lower.includes('terms and conditions')) {
        classification = 'policy document';
      } else if (lower.includes('evidence') || lower.includes('exhibit')) {
        classification = 'legal evidence or exhibit';
      } else if (lower.includes('case') && (lower.includes('number') || lower.includes('file'))) {
        classification = 'legal case file';
      } else {
        classification = 'text document';
      }
    } else if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
      // Filename-based classification for PDFs
      if (fileName.includes('affidavit')) {
        classification = 'legal affidavit (PDF)';
      } else if (fileName.includes('contract') || fileName.includes('agreement')) {
        classification = 'legal contract (PDF)';
      } else if (fileName.includes('case') || fileName.includes('legal')) {
        classification = 'legal case file (PDF)';
      } else if (fileName.includes('invoice') || fileName.includes('receipt')) {
        classification = 'financial document (PDF)';
      } else {
        classification = 'PDF document';
      }
    } else if (file.type.includes('image')) {
      classification = 'image/photo (OCR processed)';
    }
    
    // Show classification but don't dominate the message
    response += `<p style="margin-top:12px;font-size:0.95em;color:var(--muted)"><em>(Looks like a <strong>${classification}</strong>)</em></p>`;
    
    // Calculate hash for action buttons (but don't push them yet - listen first)
    const arrayBuffer = await file.file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Add action buttons at the bottom (optional, after they explain)
    response += `
      <p style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border)"><strong>Or skip straight to:</strong></p>
      <button class="inline-btn" onclick="showHashDetails('${hash}', '${file.name}')">🔍 View Hash</button>
      <button class="inline-btn" onclick="sealDocument('${hash}', '${file.name}')">📜 Seal It</button>
      <button class="inline-btn" onclick="anchorHash('${hash}')">🔗 Anchor It</button>
      <button class="inline-btn" onclick="generateCaseReport('${file.name}')">⚖️ Generate Case Report</button>
    `;
    
    addMessage(response);
    
  } catch (e) {
    addMessage(`<p>❌ Error analyzing document: ${e.message}</p>`);
    console.error('File analysis error:', e);
  }
}

// Show hash details (replaces hashAndOfferActions)
window.showHashDetails = function(hash, filename) {
  addMessage(`
    <p>✅ <strong>${filename}</strong></p>
    <p><strong>SHA-512 Hash:</strong></p>
    <code style="word-break:break-all;font-size:0.85em;display:block;background:var(--bg);padding:8px;border-radius:4px">${hash}</code>
    <p>This hash is a unique cryptographic fingerprint of your document. Any modification will change it.</p>
  `);
}

async function anchorHash(hash) {
  addMessage(`<p>⏳ Anchoring hash to blockchain...</p>`);
  
  try {
    console.log('Anchoring hash:', hash, 'to', BASE + '/v1/anchor');
    const r = await fetch(BASE + '/v1/anchor', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ hash })
    });
    
    if (!r.ok) {
      const errorText = await r.text();
      throw new Error(`HTTP ${r.status}: ${errorText}`);
    }
    
    const data = await r.json();
    if (data.ok) {
      addMessage(`
        <p>✅ Hash anchored successfully!</p>
        <p><strong>Receipt:</strong></p>
        <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em">${JSON.stringify(data, null, 2)}</pre>
      `);
    } else {
      addMessage(`<p>❌ Anchor failed: ${data.error}</p>`);
    }
  } catch (e) {
    addMessage(`<p>❌ Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/anchor</p>`);
    console.error('Anchor error:', e);
  }
}

async function sealDocument(hash, filename) {
  addMessage(`<p>⏳ Generating forensic seal PDF with QR code verification...</p>`);
  
  try {
    // Generate verification URL for QR code
    const verificationUrl = `${window.location.origin}/verify.html?hash=${hash}`;
    
    console.log('Sealing document:', filename, 'hash:', hash, 'to', BASE + '/v1/seal');
    const r = await fetch(BASE + '/v1/seal', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        hash, 
        title: filename || 'Document Seal',
        notes: 'Generated via Verum Assistant',
        qrPayload: verificationUrl
      })
    });
    
    if (r.ok) {
      const blob = await r.blob();
      const url = URL.createObjectURL(blob);
      addMessage(`
        <p>✅ Seal PDF generated with QR code!</p>
        <p><strong>Verification URL:</strong> <code style="font-size:0.85em;word-break:break-all">${verificationUrl}</code></p>
        <p><em>The QR code in the PDF links to this verification page.</em></p>
        <a href="${url}" download="verum-seal-${hash.substring(0, 8)}.pdf" class="inline-btn">⬇️ Download Sealed PDF</a>
      `);
    } else {
      const err = await r.text();
      addMessage(`<p>❌ Seal generation failed (HTTP ${r.status}): ${err}</p>`);
    }
  } catch (e) {
    addMessage(`<p>❌ Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/seal</p>`);
    console.error('Seal error:', e);
  }
}

// Generate legal case report for lawyers
window.generateCaseReport = async function(filename) {
  if (!lastAnalyzedFile) {
    addMessage(`<p>❌ No document analyzed yet. Please upload a document first.</p>`);
    return;
  }
  
  addMessage(`<p>⏳ Generating legal case report...</p>`);
  
  try {
    const file = lastAnalyzedFile.files[0];
    const content = lastAnalyzedFile.content || '';
    
    // Extract case information from document
    const caseInfo = extractCaseInformation(content, file.name);
    
    // Calculate document hash
    const arrayBuffer = await file.file.arrayBuffer();
    const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    // Build case report
    let report = `
      <div style="background:var(--bg);padding:16px;border-radius:8px;border:1px solid var(--border)">
        <h3 style="margin-top:0">⚖️ Legal Case Report</h3>
        
        <h4>Document Information</h4>
        <ul>
          <li><strong>File Name:</strong> ${file.name}</li>
          <li><strong>File Size:</strong> ${(file.size / 1024).toFixed(2)} KB</li>
          <li><strong>File Type:</strong> ${file.type || 'Unknown'}</li>
          <li><strong>Analysis Date:</strong> ${new Date(lastAnalyzedFile.analyzedAt).toLocaleString()}</li>
          <li><strong>SHA-512 Hash:</strong> <code style="font-size:0.85em;word-break:break-all">${hash}</code></li>
        </ul>
        
        <h4>Case Details</h4>
        <ul>
          ${caseInfo.caseNumber ? `<li><strong>Case Number:</strong> ${caseInfo.caseNumber}</li>` : ''}
          ${caseInfo.parties.length > 0 ? `<li><strong>Parties:</strong> ${caseInfo.parties.join(', ')}</li>` : ''}
          ${caseInfo.dates.length > 0 ? `<li><strong>Key Dates:</strong> ${caseInfo.dates.join(', ')}</li>` : ''}
          ${caseInfo.documentType ? `<li><strong>Document Type:</strong> ${caseInfo.documentType}</li>` : ''}
        </ul>
        
        <h4>Content Summary</h4>
        <p>${caseInfo.summary}</p>
        
        <h4>Key Findings</h4>
        <ul>
          ${caseInfo.findings.map(f => `<li>${f}</li>`).join('')}
        </ul>
        
        <h4>Forensic Verification</h4>
        <ul>
          <li>✅ Document cryptographically hashed (SHA-512)</li>
          <li>✅ Timestamp recorded: ${new Date().toISOString()}</li>
          <li>✅ Immutable record maintained</li>
          <li>🔗 Ready for blockchain anchoring</li>
        </ul>
        
        <div style="margin-top:16px;padding-top:12px;border-top:1px solid var(--border)">
          <button class="inline-btn" onclick="anchorHash('${hash}')">🔗 Anchor to Blockchain</button>
          <button class="inline-btn" onclick="sealDocument('${hash}', '${file.name}')">📜 Generate Sealed PDF</button>
          <button class="inline-btn" onclick="exportCaseReport('${hash}')">💾 Export Report</button>
        </div>
      </div>
    `;
    
    addMessage(report);
    
  } catch (e) {
    addMessage(`<p>❌ Error generating case report: ${e.message}</p>`);
    console.error('Case report error:', e);
  }
}

// Extract case information from document content
function extractCaseInformation(content, filename) {
  const info = {
    caseNumber: null,
    parties: [],
    dates: [],
    documentType: 'Unknown',
    summary: '',
    findings: []
  };
  
  if (!content || content.includes('[Binary file') || content.includes('extraction failed')) {
    info.summary = 'Document content could not be extracted. File appears to be binary or extraction failed.';
    info.findings.push('Document requires manual review');
    return info;
  }
  
  const lower = content.toLowerCase();
  
  // Extract case number (various patterns)
  const casePatterns = [
    /case\s+(?:no\.?|number|#)?\s*:?\s*([A-Z0-9\-\/]+)/i,
    /matter\s+(?:no\.?|number|#)?\s*:?\s*([A-Z0-9\-\/]+)/i,
    /file\s+(?:no\.?|number|#)?\s*:?\s*([A-Z0-9\-\/]+)/i,
    /docket\s+(?:no\.?|number|#)?\s*:?\s*([A-Z0-9\-\/]+)/i
  ];
  
  for (const pattern of casePatterns) {
    const match = content.match(pattern);
    if (match) {
      info.caseNumber = match[1];
      break;
    }
  }
  
  // Extract parties
  const partyPatterns = [
    /plaintiff[s]?\s*:?\s*([A-Za-z\s,&]+?)(?:\n|vs|v\.|against)/i,
    /defendant[s]?\s*:?\s*([A-Za-z\s,&]+?)(?:\n|$)/i,
    /applicant[s]?\s*:?\s*([A-Za-z\s,&]+?)(?:\n|vs|v\.)/i,
    /respondent[s]?\s*:?\s*([A-Za-z\s,&]+?)(?:\n|$)/i
  ];
  
  for (const pattern of partyPatterns) {
    const match = content.match(pattern);
    if (match && match[1].trim().length > 0) {
      info.parties.push(match[1].trim());
    }
  }
  
  // Extract dates
  const datePattern = /\b(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}|\d{4}[-\/]\d{1,2}[-\/]\d{1,2})\b/g;
  const dateMatches = content.match(datePattern);
  if (dateMatches) {
    info.dates = [...new Set(dateMatches)].slice(0, 5); // Max 5 unique dates
  }
  
  // Determine document type
  if (lower.includes('affidavit') || lower.includes('sworn statement')) {
    info.documentType = 'Affidavit / Sworn Statement';
  } else if (lower.includes('complaint')) {
    info.documentType = 'Legal Complaint';
  } else if (lower.includes('contract') || lower.includes('agreement')) {
    info.documentType = 'Contract / Agreement';
  } else if (lower.includes('invoice') || lower.includes('receipt')) {
    info.documentType = 'Financial Document';
  } else if (lower.includes('evidence') || lower.includes('exhibit')) {
    info.documentType = 'Evidence / Exhibit';
  } else if (lower.includes('motion') || lower.includes('petition')) {
    info.documentType = 'Motion / Petition';
  } else if (filename.toLowerCase().includes('case')) {
    info.documentType = 'Case File';
  }
  
  // Generate summary (first 500 chars of readable content)
  const cleanContent = content.replace(/\s+/g, ' ').trim();
  if (cleanContent.length > 500) {
    info.summary = cleanContent.substring(0, 500) + '...';
  } else {
    info.summary = cleanContent || 'No content summary available.';
  }
  
  // Generate findings based on content analysis
  if (info.caseNumber) {
    info.findings.push(`Case number identified: ${info.caseNumber}`);
  }
  if (info.parties.length > 0) {
    info.findings.push(`${info.parties.length} party/parties identified`);
  }
  if (info.dates.length > 0) {
    info.findings.push(`${info.dates.length} date(s) referenced in document`);
  }
  if (lower.includes('fraud') || lower.includes('fraudulent')) {
    info.findings.push('⚠️ Document contains references to fraud');
  }
  if (lower.includes('contradict') || lower.includes('inconsisten')) {
    info.findings.push('⚠️ Document mentions contradictions or inconsistencies');
  }
  if (lower.includes('evidence') || lower.includes('proof')) {
    info.findings.push('Document contains evidentiary material');
  }
  
  if (info.findings.length === 0) {
    info.findings.push('Document appears to be standard legal documentation');
  }
  
  return info;
}

// Export case report as JSON
window.exportCaseReport = function(hash) {
  if (!lastAnalyzedFile) {
    showToast('❌ No case data to export');
    return;
  }
  
  const file = lastAnalyzedFile.files[0];
  const content = lastAnalyzedFile.content || '';
  const caseInfo = extractCaseInformation(content, file.name);
  
  const reportData = {
    metadata: {
      exportedAt: new Date().toISOString(),
      verumOmnisVersion: 'v5.2.6',
      forensicHash: hash
    },
    document: {
      fileName: file.name,
      fileSize: file.size,
      fileType: file.type,
      analyzedAt: lastAnalyzedFile.analyzedAt,
      sha512Hash: hash
    },
    caseDetails: caseInfo
  };
  
  const blob = new Blob([JSON.stringify(reportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `case-report-${hash.substring(0, 8)}.json`;
  a.click();
  
  showToast('📥 Case report exported');
}

async function handleTextMessage(text) {
  const lower = text.toLowerCase();
  
  // Check for actions on uploaded document
  if (lastAnalyzedFile) {
    
    // REFLECT BACK: If they're explaining their situation, acknowledge it
    const storyKeywords = ['bank', 'court', 'lawyer', 'judge', 'fraud', 'scam', 'ignored', 'refused', 'denied', 
                          'lied', 'altered', 'forged', 'fake', 'wrong', 'incorrect', 'dispute', 'problem', 'case'];
    const hasStoryContext = storyKeywords.some(keyword => lower.includes(keyword));
    
    if (hasStoryContext && text.length > 20 && !lower.includes('seal') && !lower.includes('anchor') && !lower.includes('report')) {
      // They're telling their story - reflect it back
      addMessage(`
        <p><strong>Okay, I hear you.</strong></p>
        <p>You're saying: <em>"${text}"</em></p>
        <p>Right. Let me look at <strong>${lastAnalyzedFile.files[0].name}</strong> against that.</p>
        <p>What do you want me to do with it?</p>
        <ul>
          <li><strong>"Seal it"</strong> — Lock this version down so no one can claim it was different</li>
          <li><strong>"Check for fraud"</strong> — I'll scan for dodgy patterns or contradictions</li>
          <li><strong>"Summarize it"</strong> — I'll extract the key info and explain what it says</li>
          <li><strong>"Anchor it"</strong> — Timestamp it on blockchain for proof</li>
          <li><strong>"Generate case report"</strong> — Create a structured legal case report for lawyers</li>
        </ul>
      `);
      return;
    }
    
    // Case report commands
    if (lower.includes('case report') || lower.includes('generate report') || lower.includes('legal report')) {
      await generateCaseReport(lastAnalyzedFile.files[0].name);
      return;
    }
    
    // Seal/hash commands
    if (lower.includes('seal') || lower.includes('seal it') || lower.includes('generate seal')) {
      const file = lastAnalyzedFile.files[0];
      const arrayBuffer = await file.file.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      await sealDocument(hash, file.name);
      return;
    }
    
    // Anchor commands
    if (lower.includes('anchor') || lower.includes('blockchain')) {
      const file = lastAnalyzedFile.files[0];
      const arrayBuffer = await file.file.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest('SHA-512', arrayBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      await anchorHash(hash);
      return;
    }
    
    // Summarize/explain commands
    if (lower.includes('summarize') || lower.includes('explain') || lower.includes('what does it say')) {
      const file = lastAnalyzedFile.files[0];
      if (lastAnalyzedFile.content && lastAnalyzedFile.content.trim().length > 0) {
        const preview = lastAnalyzedFile.content.substring(0, 1000);
        addMessage(`
          <p><strong>📄 Document Summary</strong></p>
          <p><strong>File:</strong> ${file.name}</p>
          <p><strong>Content preview (first 1000 chars):</strong></p>
          <pre style="background:var(--bg);padding:12px;border-radius:4px;font-size:0.9em;max-height:300px;overflow:auto;white-space:pre-wrap">${preview}${lastAnalyzedFile.content.length > 1000 ? '...' : ''}</pre>
          <p><em>This is raw text extraction. For deeper analysis, I would need server-side PDF parsing capabilities.</em></p>
        `);
      } else {
        addMessage(`
          <p><strong>📄 Cannot Summarize PDF</strong></p>
          <p>This is a PDF file and I cannot extract text content in the browser. To analyze the content, I would need:</p>
          <ul>
            <li>Server-side PDF parsing (not yet implemented)</li>
            <li>Or you can describe what the document contains</li>
          </ul>
          <p>I can still create a forensic seal, hash, or blockchain anchor for verification purposes.</p>
        `);
      }
      return;
    }
    
    // Check/investigate commands
    if (lower.includes('check') || lower.includes('investigate') || lower.includes('contradict') || lower.includes('fraud')) {
      addMessage(`
        <p><strong>Right, let's dig into it.</strong></p>
        <p>Here's what I can check:</p>
        <ul>
          <li><strong>Metadata</strong> — When it was created, by whom, with what software</li>
          <li><strong>Contradictions</strong> — Needs text content and something to compare it against</li>
          <li><strong>Hash fingerprint</strong> — SHA-512 cryptographic signature</li>
          <li><strong>Tampering</strong> — Compare current version against a known-good hash</li>
        </ul>
        <p><em>Want me to run the full forensic check? Just say "yes" or hit the buttons.</em></p>
      `);
      return;
    }
  }
  
  // Check if user is asking about the uploaded document
  if (lastAnalyzedFile && (
    lower.includes('what is') || 
    lower.includes('what\'s') || 
    lower.includes('tell me about') ||
    lower.includes('describe') ||
    lower.includes('analyze') ||
    lower.includes('read') ||
    lower.includes('summarize') ||
    lower.includes('the document') ||
    lower.includes('this document') ||
    lower.includes('the file') ||
    lower.includes('this file') ||
    lower === 'this' ||
    lower === 'that'
  )) {
    const file = lastAnalyzedFile.files[0];
    let response = `<p>You uploaded <strong>${file.name}</strong> (${(file.size / 1024).toFixed(1)} KB) `;
    
    if (lastAnalyzedFile.content && lastAnalyzedFile.content.trim().length > 0 && 
        !lastAnalyzedFile.content.includes('[PDF contains no extractable text')) {
      response += `and I've read it. Here's what I found:</p>`;
      
      const content = lastAnalyzedFile.content.toLowerCase();
      
      // Detailed analysis based on content
      if (content.includes('contract') || content.includes('agreement')) {
        response += `<p>📄 <strong>Document Type:</strong> Legal Contract or Agreement</p>
        <p>This appears to be a legal document that may contain binding obligations. I can help you:</p>
        <ul>
          <li>Create a tamper-proof sealed copy to prove the document existed at this time</li>
          <li>Generate a SHA-512 hash for verification purposes</li>
          <li>Anchor it to blockchain for permanent timestamped proof</li>
        </ul>
        <p><em>Would you like me to seal this document or create a verification hash?</em></p>`;
      } else if (content.includes('invoice') || content.includes('receipt') || content.includes('payment')) {
        response += `<p>💰 <strong>Document Type:</strong> Financial Record</p>
        <p>This looks like a financial document. Creating a sealed version ensures the amounts and dates can't be disputed later.</p>`;
      } else {
        response += `<p>📝 <strong>Document Type:</strong> Text Document</p>
        <p>Content preview (first 300 chars):</p>
        <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em;max-height:150px;overflow:auto">${lastAnalyzedFile.content.substring(0, 300)}...</pre>`;
      }
    } else if (lastAnalyzedFile.content && lastAnalyzedFile.content.includes('[PDF contains no extractable text')) {
      response += `but it looks like a scanned PDF (image-based). I can't extract text from images yet.</p>
      <p><strong>What I can still do:</strong></p>
      <ul>
        <li>Generate a SHA-512 hash to fingerprint it</li>
        <li>Create a sealed PDF certificate with watermarks</li>
        <li>Anchor the hash to blockchain for permanent proof</li>
      </ul>
      <p><em>Tell me what type of document it is (e.g., "it's a legal contract") and I can give you better advice. Or just say "seal it" and I'll make it tamper-proof.</em></p>`;
    } else {
      response += `but I couldn't extract the text. This might be a scanned/image-based PDF or a binary file.</p>
      <p><strong>But here's what I know:</strong></p>
      <ul>
        <li>Name: ${file.name}</li>
        <li>Size: ${(file.size / 1024).toFixed(1)} KB</li>
        <li>Type: ${file.type || 'Unknown'}</li>
      </ul>
      <p><strong>What I can do right now:</strong></p>
      <ul>
        <li>Generate a SHA-512 hash to fingerprint it</li>
        <li>Create a sealed PDF certificate with watermarks</li>
        <li>Anchor the hash to blockchain for permanent proof</li>
      </ul>
      <p><em>Tell me what type of document it is (e.g., "it's a legal contract") and I can give you better advice. Or just say "seal it" and I'll make it tamper-proof.</em></p>`;
    }
    
    addMessage(response);
    return;
  }
  
  // Check for contradiction detection request
  if (lower.includes('contradict') || lower.includes('check') || lower.includes('verify text')) {
    addMessage(`<p>⏳ Right, scanning this for contradictions...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/contradict', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text, meta: {}, timeline: [] })
      });
      
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      
      const data = await r.json();
      if (data.ok) {
        const findings = data.result.findings || [];
        if (findings.length === 0) {
          addMessage(`<p>✅ Looks clean. No contradictions found.</p>`);
        } else {
          addMessage(`
            <p>⚠️ Hold on — found ${findings.length} dodgy ${findings.length === 1 ? 'bit' : 'bits'}:</p>
            <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em">${JSON.stringify(findings, null, 2)}</pre>
          `);
        }
      }
    } catch (e) {
      addMessage(`<p>❌ Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/contradict</p>`);
      console.error('Contradict API error:', e);
    }
    return;
  }
  
  // Check for constitution/policy request
  if (lower.includes('constitution') || lower.includes('policy') || lower.includes('rules')) {
    addMessage(`<p>⏳ Fetching constitutional policy...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/assistant', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mode: 'policy' })
      });
      
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      
      const data = await r.json();
      if (data.ok) {
        addMessage(`
          <p>✅ Constitution retrieved:</p>
          <pre style="background:var(--bg);padding:8px;border-radius:4px;font-size:0.85em;max-height:300px;overflow:auto">${JSON.stringify(data.constitution, null, 2)}</pre>
          <p><strong>Manifest version:</strong> ${data.manifest.version}</p>
        `);
      }
    } catch (e) {
      addMessage(`<p>❌ Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/assistant</p>`);
      console.error('Policy API error:', e);
    }
    return;
  }
  
  // Check for licensing/pricing info
  if (lower.includes('price') || lower.includes('cost') || lower.includes('free') || lower.includes('licensing')) {
    addMessage(`<p>⏳ Fetching licensing information...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/notice');
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      const data = await r.json();
      if (data.ok) {
        addMessage(`
          <p>💰 <strong>Licensing Terms:</strong></p>
          <p><strong>Citizens:</strong> ${data.notice.citizen}</p>
          <p><strong>Institutions:</strong> ${data.notice.institution}</p>
        `);
      }
    } catch (e) {
      addMessage(`<p>❌ Error: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">API: ${BASE}/v1/notice</p>`);
      console.error('Notice API error:', e);
    }
    return;
  }
  
  // Natural conversational responses
  if (lower.includes('how are you') || lower.includes('how r u') || lower.includes('how do you do')) {
    const responses = [
      `<p>All good. What've you got?</p>`,
      `<p>Yeah, I'm good. Need something verified?</p>`,
      `<p>Doing alright. What's up?</p>`
    ];
    addMessage(responses[Math.floor(Math.random() * responses.length)]);
    return;
  }
  
  if (lower.includes('who are you') || lower.includes('what are you') || lower.includes('tell me about yourself')) {
    addMessage(`<p>I'm Verum Omnis — a forensic firewall against lies, fraud, and manipulation.</p>
      <p>I catch contradictions, verify documents, and seal them so no one can tamper with them. Upload something dodgy and I'll tell you exactly what's wrong with it.</p>`);
    return;
  }
  
  if (lower.includes('thank') || lower.includes('thanks')) {
    const responses = [
      `<p>You're welcome! Happy to help.</p>`,
      `<p>Anytime. That's what I'm here for.</p>`,
      `<p>No problem! Come back if you need anything else.</p>`,
      `<p>Glad I could help. I'm always here.</p>`
    ];
    addMessage(responses[Math.floor(Math.random() * responses.length)]);
    return;
  }
  
  // Greetings - just be normal
  if (lower.match(/^(hello|hi|hey|greetings|yo|sup)(\s+(there|everyone|friend|mate))?$/i) || 
      lower.match(/^good\s+(morning|afternoon|evening|day)$/i) ||
      lower.match(/^(whats?\s*up|howdy)$/i)) {
    const greetings = [
      `<p>Alright, what've you got for me?</p>`,
      `<p>Hey. Upload a document or just ask me something.</p>`,
      `<p>What's up? Got something dodgy you need checked?</p>`,
      `<p>Right, let's see what you've got.</p>`
    ];
    addMessage(greetings[Math.floor(Math.random() * greetings.length)]);
    return;
  }
  
  // Help/capabilities
  if (lower.includes('what can you do') || lower.includes('how do you work') || lower.includes('help me') || lower.includes('help') ||
      lower.includes('can you read') || lower.includes('can you analyze') || lower.includes('do you read') ||
      lower.includes('can you check') || lower.includes('are you able')) {
    addMessage(`<p>Yeah, I can read documents. Upload one and I'll tell you what it says.</p>
      <p>Here's what I do:</p>
      <ul>
        <li><strong>Read documents</strong> — PDFs (text or scanned), text files, images with OCR</li>
        <li>Tell you if something looks dodgy or has contradictions</li>
        <li>Generate <strong>legal case reports</strong> for lawyers with document analysis</li>
        <li>Seal them with forensic-grade PDFs (SHA-512, watermarks, QR codes — the full kit)</li>
        <li>Anchor hashes so they're timestamped and tamper-proof</li>
        <li>Explain everything in plain English before I do anything</li>
      </ul>
      <p>Upload a file and I'll walk you through it. No jargon, no bullshit.</p>
      <p><em>Pro tip: Even scanned documents work — I'll run OCR automatically.</em></p>`);
    return;
  }
  
  // Test API connection only if specifically asked
  if (lower.includes('test api') || lower.includes('check connection')) {
    addMessage(`<p>⏳ Testing API connection...</p>`);
    
    try {
      const r = await fetch(BASE + '/v1/verify');
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      const data = await r.json();
      addMessage(`
        <p>✅ <strong>API Connected!</strong></p>
        <p>Pack: ${data.pack}</p>
        <p>Time: ${data.time}</p>
        <p style="font-size:0.85em;color:var(--muted)">Endpoint: ${BASE}</p>
      `);
    } catch (e) {
      addMessage(`<p>❌ API Connection Failed: ${e.message}</p><p style="font-size:0.85em;color:var(--muted)">Endpoint: ${BASE}/v1/verify</p>`);
      console.error('API test error:', e);
    }
    return;
  }
  
  // Default: Natural conversational fallback
  const responses = [
    `<p>Not sure what you're asking. Upload a document or ask me something like:</p>
     <ul>
       <li>"Can you read this file?"</li>
       <li>"Check for contradictions"</li>
       <li>"Seal it"</li>
       <li>"What can you do?"</li>
     </ul>`,
    
    `<p>I'm not following. Want to upload something? Or just ask:</p>
     <ul>
       <li>"What do you do?"</li>
       <li>"How do I verify a document?"</li>
       <li>"Can you analyze PDFs?"</li>
     </ul>`,
    
    `<p>Hmm, I need a bit more. Try:</p>
     <ul>
       <li>Upload a document (📎 button)</li>
       <li>Ask "What can you do?"</li>
       <li>Say "Seal this file" or "Check for fraud"</li>
     </ul>`
  ];
  
  // Pick a random helpful response
  const randomResponse = responses[Math.floor(Math.random() * responses.length)];
  addMessage(randomResponse);
}

async function sendMessage() {
  const text = userInput.value.trim();
  
  if (!text && uploadedFiles.length === 0) return;
  
  // Show user message
  if (text) {
    addMessage(`<p>${text}</p>`, true);
  }
  
  if (uploadedFiles.length > 0) {
    addMessage(`<p>📎 Attached ${uploadedFiles.length} file(s)</p>`, true);
  }
  
  userInput.value = '';
  
  // If files uploaded, send to AI assistant for analysis
  if (uploadedFiles.length > 0) {
    await analyzeFilesWithAI(uploadedFiles, text);
    uploadedFiles = [];
    uploadedFilesDiv.innerHTML = '';
    fileInput.value = '';
  } else if (text) {
    // Just text, no files
    await handleTextMessage(text);
  }
}

// Voice input setup
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = 'en-US';
  
  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    userInput.value = transcript;
    isListening = false;
    updateVoiceButton();
  };
  
  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
    isListening = false;
    updateVoiceButton();
    
    let errorMsg = 'Voice input error';
    if (event.error === 'not-allowed' || event.error === 'permission-denied') {
      errorMsg = 'Microphone permission denied. Please enable microphone access.';
    } else if (event.error === 'no-speech') {
      errorMsg = 'No speech detected. Please try again.';
    } else if (event.error === 'network') {
      errorMsg = 'Network error. Please check your connection.';
    }
    
    showToast('❌ ' + errorMsg);
  };
  
  recognition.onend = () => {
    isListening = false;
    updateVoiceButton();
  };
} else {
  // Hide voice button if not supported
  document.getElementById('voiceBtn').style.display = 'none';
}

function toggleVoiceInput() {
  if (!recognition) return;
  
  if (isListening) {
    recognition.stop();
    isListening = false;
  } else {
    recognition.start();
    isListening = true;
    showToast('🎤 Listening...');
  }
  updateVoiceButton();
}

function updateVoiceButton() {
  const btn = document.getElementById('voiceBtn');
  if (btn) {
    btn.textContent = isListening ? '🔴' : '🎤';
    btn.style.background = isListening ? '#ef4444' : '';
  }
}

// Export conversation to PDF
async function exportConversation() {
  showToast('📄 Generating PDF...');
  
  // Calculate hash of entire conversation
  const conversationText = conversationHistory.map(m => m.html.replace(/<[^>]*>/g, '')).join('\n\n');
  const encoder = new TextEncoder();
  const data = encoder.encode(conversationText);
  const hashBuffer = await crypto.subtle.digest('SHA-512', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  
  try {
    const r = await fetch(BASE + '/v1/seal', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        hash, 
        title: 'Verum Conversation Export',
        notes: `Exported ${new Date().toISOString()} - ${conversationHistory.length} messages`
      })
    });
    
    if (r.ok) {
      const blob = await r.blob();
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `verum-conversation-${hash.substring(0, 8)}.pdf`;
      a.click();
      showToast('✅ PDF downloaded');
    } else {
      showToast('❌ Export failed');
    }
  } catch (e) {
    showToast('❌ Error: ' + e.message);
  }
}

// Enter key to send
userInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

// Don't show welcome message - keep chat clean and empty initially
// Users can start by uploading documents or asking questions

// Explicitly expose functions to global scope for onclick handlers
window.sendMessage = sendMessage;
window.toggleTheme = toggleTheme;
window.exportConversation = exportConversation;
window.clearHistory = clearHistory;
window.toggleVoiceInput = toggleVoiceInput;

// Also attach event listeners directly (backup for onclick)
document.addEventListener('DOMContentLoaded', () => {
  // Send button
  const sendBtn = document.querySelector('.chat-btn-send');
  if (sendBtn) {
    sendBtn.addEventListener('click', (e) => {
      e.preventDefault();
      sendMessage();
    });
  }
  
  // Theme toggle
  const themeBtn = document.getElementById('themeBtn');
  if (themeBtn) {
    themeBtn.addEventListener('click', (e) => {
      e.preventDefault();
      toggleTheme();
    });
  }
  
  // Export button
  const exportBtn = document.getElementById('exportBtn');
  if (exportBtn) {
    exportBtn.addEventListener('click', (e) => {
      e.preventDefault();
      exportConversation();
    });
  }
  
  // Clear history button
  const clearBtn = document.getElementById('clearBtn');
  if (clearBtn) {
    clearBtn.addEventListener('click', (e) => {
      e.preventDefault();
      clearHistory();
    });
  }
  
  // Voice button
  const voiceBtn = document.getElementById('voiceBtn');
  if (voiceBtn) {
    voiceBtn.addEventListener('click', (e) => {
      e.preventDefault();
      toggleVoiceInput();
    });
  }
});
</script>

</body></html>
